@mixin media-styles(){

  // base styles
  html { font-size: unit-assert(map-get($base, 'html-scale'), em); }
  body { line-height: map-get($base, 'line-height'); }

  @if $media != () {

    // $media-keys-string: ();
    // @each $key in map-keys($media) { $media-keys-string: append($media-keys-string, quote($key), 'comma'); }

    body::before {
      width: 0;
      height: 0;
      display: block;
      overflow: hidden;
      // content: '{ "current" : "default", "all": ["#{$media-keys-string}"] }';
      content: 'base';
    }

    // head { font-family: '{ "current" : "default", "all": ["#{$media-keys-string}"] }'; }
    head { font-family: 'base'; }

    // dummy element to catch breakpoint transitions
    #{$media-transition-class} { width: 0px; transition: width 1ms; }

    @each $alias, $medium in $media {

      @media (min-width: #{map-get($medium, 'breakpoint')}) {

        // body::before { content: '{ "current" : "#{$alias}", "all": ["#{$media-keys-string}"] }'; }
        body::before { content: "#{$alias}";; }

        // head { font-family: '{ "current" : "#{$alias}", "all": ["#{$media-keys-string}"] }'; }
        head { font-family: "#{$alias}"; }

        // dummy element to track breakpoint transition
        #{$media-transition-class} { width: index(map-keys($media), $alias) % 2 * 1px; }

        // styles, if spec'd
        // @if $column-ratio { .l--col_typo { width: percentage($column-ratio) !important; } }
        @if _has-keys($media-orig, $alias, 'font-size') { html { font-size: unit-assert(map-get($medium, 'html-scale'), em); } }
        @if _has-keys($media-orig, $alias, 'line-height') { body { line-height: map-get($medium, 'line-height'); } }
      }

    }
  }
}

// MEDIA INIT

// normalize medium units
@function medium-normalize($medium) {

  // correct for font-size and line-height units/non-units
  $font-size: map-get($medium, 'font-size');
  $line-height: map-get($medium, 'line-height');
  @if unit($font-size) != 'px' { $font-size: unit-strip($font-size) * 16px; }
  @if unit($line-height) == 'px' { $line-height: $line-height / $font-size; }
  $corrections: (
    'font-size': $font-size,
    'line-height': $line-height,
    'html-scale': unit-strip($font-size / 16px)
  );
  // TODO: additional function to resolve breakpoint units and/or versus column-count
  // $breakpoint: map-get($medium, 'breakpoint');
  // @if $breakpoint and unit($breakpoint) != 'em' {
  //   $corrections: map-merge($corrections, ('breakpoint': $breakpoint));
  // }
  // merge additional corrections if necessary
  @each $key, $value in map-remove($medium, 'font-size', 'line-height', 'breakpoint') {
    @if unit($value) == 'px' { $corrections: map-merge($corrections, ($key: $value / $font-size * 1rem)); }
  }
  // return merged corrections
  @return map-merge($medium, $corrections);
}

// populate $base and $media objects
@mixin media-init($output: true){

  // backup $base
  $base-orig: $base !global;

  // merge $base against defaults, normalize units
  $base: medium-normalize(map-merge((
    font-size: 16px,
    line-height: 1.5,
    font-size-mod: 1.5,
    margin-x: 1rem,
    margin-x-mod: 2,
    margin-y: 1rem,
    margin-y-mod: 2,
    page-top: 1rem,
    page-right: 1rem,
    page-bottom: 1rem,
    page-left: 1rem,
    // line-length: 30,
    // column-ratio: 1 // n.b. wherever this is less than one, will override breakpoint
  ), $base)) !global;

  // backup $media; if media is not empty, proceed
  $media-orig: $media !global;

  @if $media != () {

    // temp variable for recursive merging
    $current: $base;

    // collect and sort the breakpoint media ; TODO -- change to sassdash
    // $sorted-media: maps-sort(maps-collect($media, 'breakpoint'), 'breakpoint');
    // !!! above is obsolete, if we are now allowing typo-columns to retro-determine breakpoint

    @each $alias, $medium in $media {

      // merge current medium against ref-medium and normalize units
      $current: medium-normalize(map-merge($current, $medium));

      // calc and merge additional props
      $breakpoint: map-get($current, 'breakpoint');
      $page-x: map-get($current, 'page-right') + map-get($current, 'page-left');

      // $line-length: map-get($current, 'line-length');
      // $column-ratio: map-get($medium, 'column-ratio'); // spec medium only
      // @if $column-ratio and $column-ratio < 1 {
      //   $margin-x: map-get($current, 'margin-x');
      //   $breakpoint: unit-assert((($line-length) / $column-ratio  - $margin-x + $page-x) * $html-scale, em); // correct ?
      //   $current: map-merge($current, ('breakpoint': $breakpoint))
      // }

      $body-width: unit-assert($breakpoint / map-get($current, 'html-scale'), rem);
      $current: map-merge($current, (
        'body-width': $body-width,
        'content-width': $body-width - $page-x
      ));

      // merge reference back to master
      $media: map-merge($media, ($alias: $current)) !global;

    }
  }

  // check if breakpoint order is okay; warn if not
  // $keys-sorted: map-keys(maps-sort($media, 'breakpoint'));
  // $keys-orig: map-keys($media-orig);
  // @if $keys-sorted != $keys-orig { @warn 'breakpoints out of order; should be #{$keys-sorted}.'; }

  @if $output { @include media-styles(); }
}

