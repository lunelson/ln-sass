/////////////////
// GRID MIXINS //
/////////////////


// grid
@mixin grid($n: 0, $columns: null) {
  @if $columns { &::before { content: '#{$columns} .#{map-get($layout-classes, 'cell')}'; } }
  @extend .#{map-get($layout-classes, 'grid')};
  @include media((for: margin-x)) {
    margin-left: margin-x($n) / -2;
    margin-right: margin-x($n) / -2;
  }
}

// cell
@mixin cell($n: 0, $width...) {
  @extend .#{map-get($layout-classes, 'cell')};
  @include media((for: margin-x)) {
    padding-left: margin-x($n) / 2;
    padding-right: margin-x($n) / 2;
  }
  @if length($width) > 0 { @include width($width...); }
}

// width / span
@mixin width($span: 1 1, $options: ()) { @include width-helper(map-merge((span: $span), $options)...); }
@mixin width-helper($span, $right: null, $left: null, $out: null, $cycle: null) {
  $n: nth($span, 1); $d: nth($span, 2);

  width: $n / $d * 100%;

  @if $right { margin-right: nth($right, 1) / if(length($right) > 1, nth($right, 2), $d) * 100%; }
  @if $left { margin-left: nth($left, 1) / if(length($left) > 1, nth($left, 2), $d) * 100%; }
  @if $cycle { &:nth-child(#{$cycle}n+1) { clear: left; } }
  @else if $out { position: absolute; #{opposite($out)}: 100%; top: auto; }
}


/////////////
// Z-INDEX //
/////////////

$z-indexes: (
  baked: 30,
  stoned: 20,
  buzzed: 10,
  sober: 0,
  asleep: -10
) !default;

@function z-index($name) { @return map-get($z-indexes, $name); }
@function z($name) { @return z-index($name); }

/////////////////
// POSITIONING //
/////////////////

@mixin position($pos, $args...) {
  position: $pos;
  @each $arg in $args { #{nth($arg, 1)}: nth($arg, 2); }
}

@mixin absolute($args...) { @include position(absolute, $args...); }
@mixin fixed($args...) { @include position(fixed, $args...); }
@mixin relative($args...) { @include position(relative, $args...); }

@mixin clearfix {
  &:after {
    content:"";
    display:table;
    clear:both;
  }
}
@mixin clearfix-legacy(){
  & { *zoom: 1; }
  &:before, &:after { content: ""; display: table; }
  &:after { clear: both; }
}

/////////////////////////
// CHILD ELEMENT SHITE //
/////////////////////////

@function child-selector($selector) {
  @if $selector {
    @if str-index($selector, '&'){
      @return '#{$selector}';
    } @else {
      @return '& > #{$selector}';
    }
  } @else {
    @return '& > *';
  }
}

@mixin child-counter($selector: 'li', $content-before:'', $content-after:''){
  $counter: unique-id();
  list-style-type: none;
  counter-reset: $counter;
  & #{child-selector($selector)} {
    counter-increment: $counter;
    &:before {
      content: '#{$content-before}' counter($counter) '#{$content-after}';
      @content;
    }
  }
}

// OLDER VERSION
// @mixin child-counter($child-selector: '> li', $content-before:'', $content-after:''){
//   $counter: unique-id();
//   list-style-type: none;
//   counter-reset: $counter;
//   & #{$child-selector} {
//     counter-increment: $counter;
//     &:before {
//       content: '#{$content-before}' counter($counter) '#{$content-after}';
//       @content;
//     }
//   }
// }

//////////////////
// CHILD LAYOUT //
//////////////////

// http://nicolasgallagher.com/an-introduction-to-css-pseudo-element-hacks/
// http://css-tricks.com/pseudo-element-roundup/

// table-layout - CSS | MDN | https://developer.mozilla.org/en-US/docs/Web/CSS/table-layout
// Fixed Table Layouts | CSS-Tricks | http://css-tricks.com/fixing-tables-long-strings/
// ungrid - the simplest responsive css grid | https://chrisnager.github.io/ungrid/
// Pure CSS, equal-width navigation tabs | http://jsfiddle.net/csswizardry/zfSt4/

@mixin child-layout($selector, $type, $options...) {

  // TABLE
  @if index(table-cell table-row cell row, $type) {
    width: 100%; // force auto size of children
    display: table;
    table-layout: fixed;
    border-collapse: collapse;
    #{child-selector($selector)} {
      @if index(table-row row, $type) {
        display: table-row;
        height: auto; // base setting
        @if index($options, left) { text-align: left; }
        @else if index($options, right) { text-align: right;}
        @else { text-align: center; }
      }
      @else {
        display: table-cell;
        width: auto; // base setting
        @if index($options, bottom) { vertical-align: bottom; }
        @else if index($options, top) { vertical-align: top;}
        @else { vertical-align: middle; }
      }
      overflow: hidden;
      @content;
    }
  }

  // INLINE BLOCK
  @else if index(inline-block iblock ib, $type) {
    font-size: 0px;
    @if index($options, justify) {
      text-align: justify;
      &:after, #{child-selector($selector)} {
        display: inline-block;
        max-width: 100%; // ff bug
        @if index($options, bottom) { vertical-align: bottom; }
        @else if index($options, middle) { vertical-align: middle;}
        @else { vertical-align: top; }
      }
      &:after {
        content: '';
        width: 100%;
      }
      #{child-selector($selector)} {
        font-size: 1rem;
        @content;
      }
    }
    @else {
      &:before, #{child-selector($selector)} {
        display: inline-block;
        max-width: 100%; // ff bug
        @if index($options, bottom) { vertical-align: bottom; }
        @else if index($options, top) { vertical-align: top;}
        @else { vertical-align: middle; }
      }
      &:before {
        content: '';
        height: 100%;
      }
      #{child-selector($selector)} {
        font-size: 1rem;
        @content;
      }
      @if index($options, left) { text-align: left; }
      @else if index($options, right) { text-align: right;}
      @else { text-align: center; }
    }
  }
}

////////////////////////////////////
// CSS PARALLAX  / Z DISPLACEMENT //
////////////////////////////////////

///////////////////////
// Z-OFFSET FUNCTION //
///////////////////////

@function offsetZ($z, $p: $parallax-perspective) {
  @if unitless($z) { @return translateZ($z); }
  @return translateZ($z) scale(1 - $z/$p);
}

/////////////////
// SETUP MIXIN //
/////////////////

$parallax-perspective: 100px; // nb this defines max positive displacement

@mixin parallax-setup {
  html.no-touch body {
    perspective: $parallax-perspective;
  }
  // perspective rendered at container level; will be inherited
  // height is full viewport, overflow-y allows scroll
  // perspective rule may need to be placed on the body element, for some browsers
  .#{$l_pre}parallax_area {
    position: relative;
    height: 100vh;
    html.no-touch & {
      // perspective: $parallax-perspective;
      overflow-x: hidden;
      overflow-y: scroll;
      perspective-origin: 100%; // fix webkit overflow bug
    }
  }
  // preserve-3d prevents child layers of a group from being collapsed
  // must not have overflow hidden or effect will break
  .#{$l_pre}parallax_group {
    position: relative;
    height: 100vh;
    html.no-touch & {
      transform-style: preserve-3d;
      .debug & {
        transform: translate3d(700px, 0, -800px) rotateY(30deg);
      }
    }
  }
  // layer is pulled out of flow and forced to fill its parent
  .#{$l_pre}parallax_layer {
    position: absolute;
    width: 100%;
    height: 100vh;
    html.no-touch & {
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      perspective-origin: 100%; // fix webkit overflow bug
    }
  }
}



