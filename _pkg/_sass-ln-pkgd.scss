// Constants
$E:     2.718281828459045;
$PI:    3.141592653589793;
$LN2:   0.6931471805599453;
$SQRT2: 1.4142135623730951;

// Returns base to the exponent power.
// @param {Number} $base The base number
// @param {Number} $exp The exponent to which to raise base
// @return {Number}
// @example
//     pow(4, 2)   // 16
//     pow(4, -2)  // 0.0625
//     pow(4, 0.2) // 1.31951
@function pow ($base, $exp) {
    @if $exp == floor($exp) {
        $r: 1;
        $s: 0;
        @if $exp < 0 {
            $exp: $exp * -1;
            $s: 1;
        }
        @while $exp > 0 {
            @if $exp % 2 == 1 {
                $r: $r * $base;
            }
            $exp: floor($exp * 0.5);
            $base: $base * $base;
        }
        @return if($s != 0, 1 / $r, $r);
    } @else {
        @return exp(log($base) * $exp);
    }
}

// Returns the factorial of a non-negative integer.
// @param {Number} $x A non-negative integer.
// @return {Number}
// @example
//     fact(0) // 1
//     fact(8) // 40320
@function fact ($x) {
    @if $x < 0 or  $x != floor($x) {
        @warn "Argument for `fact()` must be a positive integer.";
        @return null;
    }
    $ret: 1;
    @while $x > 0 {
        $ret: $ret * $x;
        $x: $x - 1;
    }
    @return $ret;
}

// Returns the square root of a number.
// @param {Number} $x
// @example
//     sqrt(2) // 1.41421
//     sqrt(5) // 2.23607
@function sqrt ($x) {
    @if $x < 0 {
        @warn "Argument for `sqrt()` must be a positive number.";
        @return null;
    }
    $ret: 1;
    @for $i from 1 through 24 {
        $ret: $ret - (pow($ret, 2) - $x) / (2 * $ret);
    }
    @return $ret;
}

// Returns E^x, where x is the argument, and E is Euler's constant, the base of the natural logarithms.
// @param {Number} $x
// @example
//     exp(1)  // 2.71828
//     exp(-1) // 0.36788
@function exp ($x) {
    $ret: 0;
    @for $n from 0 to 24 {
        $ret: $ret + pow($x, $n) / fact($n);
    }
    @return $ret;
}

// Returns a two-element list containing the normalized fraction and exponent of number.
// @param {Number} $x
// @return {List} fraction, exponent
@function frexp ($x) {
    $exp: 0;
    @if $x < 0 {
        $x: $x * -1;
    }
    @if $x < 0.5 {
        @while $x < 0.5 {
            $x: $x * 2;
            $exp: $exp - 1;
        }
    } @else if $x >= 1 {
        @while $x >= 1 {
            $x: $x / 2;
            $exp: $exp + 1;
        }
    }
    @return $x, $exp;
}

// Returns $x * 2^$exp
// @param {Number} $x
// @param {Number} $exp
@function ldexp ($x, $exp) {
    $b: if($exp >= 0, 2, 1 / 2);
    @if $exp < 0 {
        $exp: $exp * -1;
    }
    @while $exp > 0 {
        @if $exp % 2 == 1 {
            $x: $x * $b;
        }
        $b: $b * $b;
        $exp: floor($exp * 0.5);
    }
    @return $x;
}

// Returns the natural logarithm of a number.
// @param {Number} $x
// @example
//     log(2)  // 0.69315
//     log(10) // 2.30259
@function log ($x) {
    @if $x <= 0 {
        @return 0 / 0;
    }
    $k: nth(frexp($x / $SQRT2), 2);
    $x: $x / ldexp(1, $k);
    $x: ($x - 1) / ($x + 1);
    $x2: $x * $x;
    $i: 1;
    $s: $x;
    $sp: null;
    @while $sp != $s {
        $x: $x * $x2;
        $i: $i + 2;
        $sp: $s;
        $s: $s + $x / $i;
    }
    @return $LN2 * $k + 2 * $s;
}

// Returns the sine of a number.
// @param {Number} $x A number in rad or deg. Assuming unitless number to be in rad.
// @example
//     sin(1.0472) // 0.86603
//     sin(60deg)  // 0.86603
@function sin ($x) {
    $x: unitless-rad($x);
    @return cos($x - $PI / 2);
}

// Returns the cosine of a number.
// @param {Number} $x A number in rad or deg. Assuming unitless number to be in rad.
// @example
//     cos(0.7854) // 0.70711
//     cos(45deg)  // 0.70711
@function cos ($x) {
    $x: unitless-rad($x);
    $ret: 0;
    @for $n from 0 to 24 {
        $ret: $ret + pow(-1, $n) * pow($x, 2 * $n) / fact(2 * $n);
    }
    @return $ret;
}

// Returns the tangent of a number.
// @param {Number} $x A number in rad or deg. Assuming unitless number to be in rad.
// @example
//     tan(0.5236) // 0.57735
//     tan(30deg)  // 0.57735
@function tan ($x) {
    $x: unitless-rad($x);
    @return sin($x) / cos($x);
}

// Returns the cosecant of a number.
// @param {Number} $x A number in rad or deg. Assuming unitless number to be in rad.
// @example
//     csc(1.0472) // 1.1547
//     csc(60deg)  // 1.1547
@function csc ($x) {
    $x: unitless-rad($x);
    @return 1 / sin($x);
}

// Returns the secant of a number.
// @param {Number} $x A number in rad or deg. Assuming unitless number to be in rad.
// @example
//     sec(0.7854) // 1.41422
//     sec(45deg)  // 1.41422
@function sec ($x) {
    $x: unitless-rad($x);
    @return 1 / cos($x);
}

// Returns the cotangent of a number.
// @param {Number} $x A number in rad or deg. Assuming unitless number to be in rad.
// @example
//     cot(0.5236) // 1.73205
//     cot(30deg)  // 1.73205
@function cot ($x) {
    $x: unitless-rad($x);
    @return 1 / tan($x);
}

// Returns the arcsine of a number.
// @param {Number} $x A number between -1 and 1.
// @example
//     asin(0.1) // 0.10017
//     asin(-1)  // -1.5708
@function asin ($x) {
    @if $x > 1 or $x < -1 {
        @warn "Argument for `asin()` must be a number between -1 and 1";
        @return null;
    }
    @return atan($x / sqrt(1 - $x * $x));
}

// Returns the arccosine of a number.
// @param {Number} $x A number between -1 and 1.
// @example
//     acos(0.1) // 1.47063
//     acos(-1)  // 3.14159
@function acos ($x) {
    @if $x > 1 or $x < -1 {
        @warn "Argument for `acos()` must be a number between -1 and 1";
        @return null;
    }
    @return $PI / 2 - asin($x);
}

// Returns the arctangent of a number.
// @param {Number} $x
// @example
//     atan(0.1) // 0.09967
//     atan(-1)  // -0.7854
@function atan ($x) {
    $i:  24;
    $sgn: 0;
    $a:   0;
    @if $x > 1 {
        $sgn:  1;
        $x:    1 / $x;
    } @else if $x < -1 {
        $sgn: -1;
        $x:    1 / $x;
    }
    @while $i > 0 {
        $a: ($i * $i * $x * $x) / (2 * $i + 1 + $a);
        $i: $i - 1;
    }
    @if $sgn > 0 {
        @return  $PI / 2 - $x / (1 + $a);
    } @else if $sgn < 0 {
        @return -$PI / 2 - $x / (1 + $a);
    } @else {
        @return            $x / (1 + $a);
    }
}

// Returns the arctangent of the quotient of its arguments.
// @param {Number} $y
// @param {Number} $x
// @example
//     atan2(0, 0)       // 0
//     atan2(0, -0.0)    // 3.14159
//     atan2(-0.0, 0)    // 0
//     atan2(-0.0, -0.0) // -3.14159
//     atan2(0, 1)       // 0
//     atan2(0, -1)      // 3.14159
@function atan2 ($y, $x) {
    @if $x > 0 {
        @return atan($y / $x);
    } @else if $x < 0 {
        @if $y < 0 {
            @return atan($y / $x) - $PI;
        } @else {
            @return atan($y / $x) + $PI;
        }
    } @else {
        @if $y < 0 {
            @return - $PI / 2;
        } @else if $y > 0 {
            @return $PI / 2;
        } @else {
            @if 1 / $x == 1 / 0 {
                @return 0;
            } @else {
                @if 1 / $y == 1 / 0 {
                    @return $PI;
                } @else {
                    @return -$PI;
                }
            }
        }
    }
}

// Strip unit from a number
@function strip-unit ($number) {
    @if unitless($number) {
        @return $number;
    } @else {
        @return $number / ($number * 0 + 1);
    }
}

// Convert deg to rad
@function deg-to-rad ($deg, $unit: true) {
    @return strip-unit($deg) * $PI / 180 * if($unit, 1rad, 1);
}

// Convert rad to deg
@function rad-to-deg ($rad, $unit: true) {
    @return strip-unit($rad) * 180 / $PI * if($unit, 1deg, 1);
}

// Convert to unitless rad
@function unitless-rad ($angle) {
    @if unitless($angle) {
        @return $angle;
    } @else if unit($angle) == rad {
        @return $angle / 1rad;
    } @else if unit($angle) == deg {
        @return deg-to-rad($angle, false);
    } @else if type-of($angle) != number or not unitless($angle) {
        @warn "#{ $angle } is not a valid number.";
        @return $angle;
    }
}

//            _
//           | |
//   ___ ___ | | ___  _ __
//  / __/ _ \| |/ _ \| '__|
// | (_| (_) | | (_) | |
//  \___\___/|_|\___/|_|



@function gray($n) {
  $c: $n/100*255;
  @return rgb($c,$c,$c);
}


@mixin child-counter($child-selector: '> li', $content-before:'', $content-after:''){
  $counter: unique-id();
  list-style-type: none;
  counter-reset: $counter;
  & #{$child-selector} {
    counter-increment: $counter;
    &:before {
      content: '#{$content-before}' counter($counter) '#{$content-after}';
      @content;
    }
  }
}
//  _                         _
// | |                       | |
// | | __ _ _   _  ___  _   _| |_
// | |/ _` | | | |/ _ \| | | | __|
// | | (_| | |_| | (_) | |_| | |_
// |_|\__,_|\__, |\___/ \__,_|\__|
//           __/ |
//          |___/

@mixin position($pos, $args...) {
  position: $pos;
  @each $arg in $args { #{nth($arg, 1)}: nth($arg, 2); }
}
@mixin absolute($args...) { @include position(absolute, $args...); }
@mixin fixed($args...) { @include position(fixed, $args...); }
@mixin relative($args...) { @include position(relative, $args...); }

@mixin clearfix {
  &:after {
    content:"";
    display:table;
    clear:both;
  }
}
//                  _   _
//                 | | | |
//  _ __ ___   __ _| |_| |__
// | '_ ` _ \ / _` | __| '_ \
// | | | | | | (_| | |_| | | |
// |_| |_| |_|\__,_|\__|_| |_|


@function mod-scale($base, $exp, $spread) { @return pow($base, $exp/$spread); }

@function trend($value, $basis: (0 0, 1 1)) {
  $c1: nth($basis, 1); $c2: nth($basis, 2);
  $x1: nth($c1, 1); $y1: nth($c1, 2);
  $x2: nth($c2, 1); $y2: nth($c2, 2);
  $m: ($y2 - $y1) / ($x2 - $x1);
  @return $y1 + $m * ($value - $x1);
}

//            _
//           (_)
//  _ __ ___  _ ___  ___
// | '_ ` _ \| / __|/ __|
// | | | | | | \__ \ (__
// |_| |_| |_|_|___/\___|


// output stringified number w/ suffix e.g. 1st 2nd 3rd 4th
// not compatible with libsass
// @function enum($n) {
//   $h: abs($n) % 100; $t: $h % 10;
//   @if $h > 3 and $h < 21 { @return #{$n}th; }
//   @return #{$n}#{if($h == 1, 'st', if($t == 2, 'nd', if($t == 3, 'rd', 'th')))};
// }

@function opposite($dirs) {
  $out: ();
  $opposites: ('top': bottom, 'right': left, 'bottom': top, 'left': right, 'ltr': rtl, 'rtl': ltr);
  @each $dir in $dirs {
    $opposite: map-get($opposites, $dir);
    @if $opposite {$out: append($out, $opposite); } }
  @return $out;
}

@mixin adjacent-to($args...) {
  @if length($args) == 0 {
    & + & { @content; }
  } @else {
    @if type-of(nth($args, 1)) == list { $args: join((), $args...); }
    $arr: '';
    @for $n from 1 through length($args) {
      $arr: if($n == 1, unquote('#{nth($args, 1)} + &'), append($arr, unquote(', #{nth($args,$n)} + &')));
    }
    #{$arr} { @content; }
  }
}
//  _ _     _
// | (_)   | |
// | |_ ___| |_ ___
// | | / __| __/ __|
// | | \__ \ |_\__ \
// |_|_|___/\__|___/

// convert a list to comma-separated values
@function csv($list) {
  $output: ();
  @each $item in $list {
    $output: append($output, $item, 'comma');
  }
  @return $output;
}

// convert a list to space-separated values
@function ssv($list) {
  $output: ();
  @each $item in $list {
    $output: append($output, $item, 'space');
  }
  @return $output;
}

@function remove($list, $tests...) {
  $out:(); @if length($list) == 1 { $list: nth($list, 1); }
  @each $item in $list {
    @if not index($tests, $item) { $out: append($out, $item); } }
  @return $out;
}

@function reduce($list) { @return remove($list, null, false); }


// collect and reject by type comparison
@function collect-types($list, $type) {
  $out: ();
  @if length($list) == 1 { $list: nth($list, 1); }
  @each $item in $list {
      @if type_of($item) == $type {
          $out: append($out, $item);
      }
  }
  @return if(length($out) == 1, nth($out, 1), $out);
}

@function reject-types($list, $type) {
  @if length($list) == 1 { $list: nth($list, 1); }
  @each $item in $list {
      @if type_of($item) == $type {
          $list: reject($list, $item);
      }
  }
  @return if(length($list) == 1, nth($list, 1), $list);
}

// shortcuts for above
@function collect-strings($list) { @return collect-types($list, 'string'); }
@function reject-strings($list) { @return reject-types($list, 'string'); }
@function collect-numbers($list) { @return collect-types($list, 'number'); }
@function reject-numbers($list) { @return reject-types($list, 'number'); }
@function collect-bools($list) { @return collect-types($list, 'bool'); }
@function reject-bools($list) { @return reject-types($list, 'bool'); }

@function contains($list, $item) {
  @if index($list, $item) { @return true; }
  @return false;
}

@function contains-any($list, $items) {
  @each $item in $items { @if index($list, $item) { @return true; } }
  @return false;
}

@function slice($list, $start: 1, $end: length($list), $sep: 'comma') {
  $output: ();
  @if $start >= 1 and $end >= $start {
    @for $i from $start through $end {
      $output: append($output, nth($list, $i), $sep);
    }
  }
  @return $output;
}

//      _        _
//     | |      (_)
//  ___| |_ _ __ _ _ __   __ _ ___
// / __| __| '__| | '_ \ / _` / __|
// \__ \ |_| |  | | | | | (_| \__ \
// |___/\__|_|  |_|_| |_|\__, |___/
//                        __/ |
//                       |___/

@function str-remove($str, $sub) {
  $i: str-index($str, $sub);
  @if $i == 0 { @return $str; }
  @else { @return str-remove(str-slice($str, 1, $i - 1) + str-slice($str, $i + 1, str-length($str)), $sub); }
}


//              _ _
//             (_) |
//  _   _ _ __  _| |_ ___
// | | | | '_ \| | __/ __|
// | |_| | | | | | |_\__ \
//  \__,_|_| |_|_|\__|___/

// updated 2015-03-06 08:31:14

@function one($unit) {
  $one: ('em': 1em, 'ex': 1ex, 'ch': 1ch, 'rem': 1rem, '%': 1%, 'vw': 1vw, 'vh': 1vh, 'vmin': 1vmin, 'vmax': 1vmax, 'cm': 1cm, 'mm': 1mm, 'in': 1in, 'px': 1px, 'pt': 1pt, 'pc': 1pc, 'deg': 1deg, 'grad': 1grad, 'rad': 1rad, 'turn': 1turn, 's': 1s, 'ms': 1ms, 'dpi': 1dpi, 'dpcm': 1dpcm, 'dppx': 1dppx);
  @return map-get($one, $unit) or 1;
}
@function strip($value) { @return if(unitless($value), $value, $value / one(unit($value))); }
@function assert($value, $unit: '') { @return strip($value) * one($unit); }

// the classic unit stripping hack
@function strip-alt($value){ @return if(unitless($value), $value, $value / (0 * $value + 1)); }

@function relativize($value, $reference: 1) {
  $reference-unit: unit($reference);
  $value-unit: unit($value);
  // if reference unit is percent, warn and return value
  @if $reference-unit == '%' { @warn 'cannot relativize to a relative reference'; @return $value; }
  // if value is in percent it's already relative
  @if $value-unit == '%' { $value: $value / 100%; }
  // if the units are equal, or either is unitless, divide stripped
  @else if unitless($value) or unitless($reference) or $reference-unit == $value-unit { $value: strip-alt($value) / strip-alt($reference); }
  // if reference is em/rem
  @else if index('em' 'rem', $reference-unit) {
    @if index('em' 'rem', $value-unit) { $value: strip-alt($value) / strip-alt($reference); }
    @else { $value: strip-alt($value) / strip-alt($reference) / 16; }
  }
  // if reference is px
  @else if $reference-unit == 'px' {
    @if index('em' 'rem', $value-unit) { $value: strip-alt($value) / strip-alt($reference) * 16; }
    @else { $value: strip-alt($value) / strip-alt($reference); }
  }
  @return $value;
}
//        _                                _                      _ _
//       (_)                              | |                    (_) |
// __   ___  _____      ___ __   ___  _ __| |_ ______ _   _ _ __  _| |_ ___
// \ \ / / |/ _ \ \ /\ / / '_ \ / _ \| '__| __|______| | | | '_ \| | __/ __|
//  \ V /| |  __/\ V  V /| |_) | (_) | |  | |_       | |_| | | | | | |_\__ \
//   \_/ |_|\___| \_/\_/ | .__/ \___/|_|   \__|       \__,_|_| |_|_|\__|___/
//                       | |
//                       |_|

@function vx($rate, $base: 0, $vunit: 1vw) {
  $relbase1: null;
  $break1: null;
  $relbase2: null;
  $break2: null;
  @if type-of($base) == 'list' {
    $break1: nth($base, 2);
    // relativize base relative to break1
    $relbase1: relativize(nth($base, 1), $break1);
    @if type-of($rate) == 'list' {
      // resolve break2 in units of break1
      $break2: relativize(nth($rate, 2), $break1) * $break1;
      // resolve base2 in units of break1
      $relbase2: relativize(nth($rate, 1), $break1);
      // resolve rate in units of break2-break1
      $rate: ($relbase2 - $relbase1) * $break1 / ($break2 - $break1) * 100;
    }
    $rate: strip-alt($rate);
    $base: ($relbase1 - $rate/100) * $break1;
  }
  @return calc(#{$rate * $vunit} + #{$base})
  // @return '
  //   base: #{$base},
  //   rate: #{$rate},
  //   break-1 #{$break1},
  //   break-2: #{$break2}
  // ';
}

@function vwx($rate, $base:0) { @return vx($rate, $base, 1vw); }
@function vhx($rate, $base:0) { @return vx($rate, $base, 1vh); }
///                                                                  _
///                                                                 | |
///  ___  __ _ ___ ___ ______ _ __ ___   __ _ _ __  ___ ______ _ __ | |_   _ ___
/// / __|/ _` / __/ __|______| '_ ` _ \ / _` | '_ \/ __|______| '_ \| | | | / __|
/// \__ \ (_| \__ \__ \      | | | | | | (_| | |_) \__ \      | |_) | | |_| \__ \
/// |___/\__,_|___/___/      |_| |_| |_|\__,_| .__/|___/      | .__/|_|\__,_|___/
///                                          | |              | |
///                                          |_|              |_|
///  Sass Maps Plus 0.9.2
///  Advanced map and list-map manipulation for all versions of Sass
///  MIT License
///  @author Lu Nelson

//        _   _ _ _ _   _
//       | | (_) (_) | (_)
//  _   _| |_ _| |_| |_ _  ___  ___
// | | | | __| | | | __| |/ _ \/ __|
// | |_| | |_| | | | |_| |  __/\__ \
//  \__,_|\__|_|_|_|\__|_|\___||___/

/// Return a sub-list from a list, *sliced* from/to given indices
/// @access private
/// @group utilities
/// @param {List} $list - List to slice
/// @param {Number} $start [1] - Start index
/// @param {Number} $end [length($list)] - End index
/// @param {String} $separator [list-separator($list)] - List separator
/// @return {List} - Sliced list
@function slice($list, $start: 1, $end: length($list), $separator: list-separator($list)) {
  $output: ();

  @if $start >= 1 and $end >= $start {
    @for $i from $start through $end {
      $output: append($output, nth($list, $i), $separator);
    }
  }

  @return $output;
}


/// Return the key (first value) from a two-item list
/// @access private
/// @group utilities
/// @param {List} $tuple - Tuple
/// @return {* | Null} - Key from `$tuple` or `null`
@function tuple-key($tuple) {
  @if length($tuple) < 1 {
    @return null;
  }

  @return nth($tuple, 1);
}


/// Return the value (second value) from a two-item list
/// @access private
/// @group utilities
/// @param {List} $tuple - Tuple
/// @return {* | Null} - Value from `$tuple` or `null`
@function tuple-value($tuple) {
  @if length($tuple) < 2 {
    @return null;
  }

  // @return nth($tuple, 2);
  @return slice($tuple, 2, length($tuple));
}


/// Return input `$string` printed `$n` times
/// @access private
/// @group utilities
/// @param {String} $string - String to repeat
/// @param {Number} $n - Number of times
/// @return {String}
@function str-multiply($string, $n) {
  $output: '';

  @if $n > 0 {
    @for $i from 1 through $n {
      $output: $output + $string;
    }
  }

  @return $output;
}


//  _ __ ___   __ _ _ __  ___
// | '_ ` _ \ / _` | '_ \/ __|
// | | | | | | (_| | |_) \__ \
// |_| |_| |_|\__,_| .__/|___/
//                 | |
//                 |_|

/// Return previous key from map, given $key
/// @access public
/// @group maps
/// @param {Map} $map - Map
/// @param {*} $key - Pivot key
/// @return {*}
/// @require {function} map-keys
@function map-prev-key($map, $key) {
  $keys: map-keys($map);
  $index: index($keys, $key) - 1;
  @return if($index >= 1, nth($keys, $index), null);
}


/// Return next key from map, given $key
/// @access public
/// @group maps
/// @param {Map} $map - Map
/// @param {*} $key - Pivot key
/// @return {*}
/// @require {function} map-keys
@function map-next-key($map, $key) {
  $keys: map-keys($map);
  $index: index($keys, $key) + 1;
  @return if($index <= length($keys), nth($keys, $index), null);
}


/// get all values from $map for keys in $keys list
/// @access public
/// @group maps
/// @param {Map} $map - map
/// @param {Arglist} $keys - keys to get
/// @return {*}
@function map-get-all($map, $keys...) {
  $out:();
  @each $key in $keys {
    $value: map-get($map, $key);
    $out: if($value, append($out, $value), $out);
  }
  @return if($out != (), $out, null);
}

/// get first value from $map for keys in $keys list
/// @access public
/// @group maps
/// @param {Map} $map - map
/// @param {Arglist} $keys - keys to get
/// @return {*}
@function map-get-any($map, $keys...) {
  @each $key in $keys {
    $value: map-get($map, $key);
    @if $value { @return $value; }
  }
  @return null;
}

/// get value at nested or 'deep' key, per $keys list
/// @access public
/// @group maps
/// @param {Map} $map - map
/// @param {Arglist} $keys - nested keys
/// @return {*}
@function map-get-nested($map, $keys...) {
  @if length($map) == 0 { @return null; }
  @each $key in $keys {
    @if type-of($map) != 'map' {
      @return $map;
    }
    $map: map-get($map, $key);
  }
  @return $map;
}

/// merge $value to $map at nested or 'deep' $key, per $kv list
/// (works in merge- or set-style syntax)
/// @access public
/// @group maps
/// @param {Map} $map - target map
/// @param {Arglist} $kv - keys and map (map is final item in list)
/// @return {Map} - Updated map
/// @require {function} slice
/// @require {function} map-get-nested
@function map-merge-nested($map, $keys-and-value...) {
  $keys-and-value-length: length($keys-and-value);
  $key-length: $keys-and-value-length - 1;
  $value: nth($keys-and-value, $keys-and-value-length);
  $value-is-map: type-of($value) == 'map';

  @if $key-length == 0 {
    $value: map-merge($map, if($value-is-map or length($value) == 0, $value, ($value: ())));
  } @else {
    @for $i from if($value-is-map, 0, 1) through $key-length {
      $new: if($i == 0, $value, (nth($keys-and-value, $keys-and-value-length - $i): $value));
      $old: if($i == $key-length, $map, map-get-nested($map, slice($keys-and-value, 1, $key-length - $i)...) or ());
      $value: if(type-of($old) == 'map', map-merge($old, $new), $new);
    }
  }

  @return $value;
}

/// return a pretty-printed string representation of a map
/// @access public
/// @group maps
/// @param {Map} $map - Map to inspect
/// @param {Number} $level [1] - Internal variable, **do not edit**
/// @return {String} - String representation of `$map`
/// @require {function} str-multiply
/// @require {function} map-inspect
@function map-inspect($map, $level: 1) {
  $tab: '  ';
  $cr: '
';

  @if type-of($map) != 'map' {
    @return '#{inspect($map)}';
  }

  $indent: str-multiply($tab, $level + 1);
  $output: '(' + $cr + $indent; $i: 1;

  @each $key, $value in $map {
    @if type-of($value) == 'map' {
      $output: $output + '#{$key}: #{map-inspect($value, $level+1)}';
    } @else {
      $output: $output + '#{$key}: #{$value}';
    }

    @if $i < length(map-keys($map)) {
      $output: $output + ',' + $cr + $indent;
    }

    $i: $i + 1;
  }

  $outdent: str-multiply($tab, $level);

  @return $output + $cr + $outdent + ')';
}



//                                                              __                              _ _     _
//                                                             / /                             | (_)   | |
//  _ __ ___   __ _ _ __ ______ _ __ ___   __ _ _ __  ___     / /   _ __ ___   __ _ _ __ ______| |_ ___| |_ ___
// | '_ ` _ \ / _` | '_ \______| '_ ` _ \ / _` | '_ \/ __|   / /   | '_ ` _ \ / _` | '_ \______| | / __| __/ __|
// | | | | | | (_| | |_) |     | | | | | | (_| | |_) \__ \  / /    | | | | | | (_| | |_) |     | | \__ \ |_\__ \
// |_| |_| |_|\__,_| .__/      |_| |_| |_|\__,_| .__/|___/ /_/     |_| |_| |_|\__,_| .__/      |_|_|___/\__|___/
//                 | |                         | |                                 | |
//                 |_|                         |_|                                 |_|

/// Collect a list-of-maps or map-of-maps, in to a new list-of-maps or map-of-maps, based on truthiness of value at key(s) in those maps
/// @access public
/// @group map-lists/map-maps
/// @param {Map|List} $maps - Map of maps, or List of maps, to collect from
/// @param {Arglist} $keys - Chain of keys to the value that will determine collections
/// @return {Map|list}
/// @require {function} map-get-nested
@function maps-collect($maps, $keys...) {

  @if length($keys) == 0 { @return $maps; }

  @if length($maps) == 0 { @return $maps; }

  $collector: ();

  $map-of-maps: type-of($maps) == 'map';

  @if $map-of-maps {

    @each $key, $map in $maps {
      $curr-value: map-get-nested($map, $keys...);
      @if $curr-value { $collector: map-merge($collector, ($key: $map)); }
    }
    @return $collector;

  } @else {

    @each $map in $maps {
      $curr-value: map-get-nested($map, $keys...);
      @if $curr-value { $collector: append($collector, $map); }
    }
    @return $collector;

  }
}


/// Global sort direction: either `asc` or `desc`
/// @access public
/// @group map-lists/map-maps
$maps-sort-dir: 'asc';


/// Sort a list-of-maps or map-of-maps, based on value at key(s) in maps
/// @access public
/// @group map-lists/map-maps
/// @param {Map|List} $maps - Map of maps, or List of maps, to sort
/// @param {Arglist} $keys - Chain of keys to the value that will be sorted for
/// @return {Map|List}
/// @require {function} map-get-nested
@function maps-sort($maps, $keys...) {

  @if length($keys) == 0 { @return $maps; }

  @if length($maps) > 1 {

    $less: ();
    $equal: ();
    $greater: ();

    $map-of-maps: type-of($maps) == 'map';

    @if $map-of-maps {

      $seed-map: nth(nth($maps, ceil(length($maps) / 2)), 2);

      $seed-value: map-get-nested($seed-map, $keys...);

      // TODO: add code to handle case of non-number values (warn and return $maps)

      @each $key, $map in $maps {

        $curr-value: map-get-nested($map, $keys...);

        @if $curr-value == $seed-value {
          $equal: map-merge($equal, ($key: $map));
        } @else if $curr-value < $seed-value {
          @if $maps-sort-dir == 'asc' {
            $less: map-merge($less, ($key: $map));
          } @else {
            $greater: map-merge($greater, ($key: $map));
          }
        } @else {
          @if $maps-sort-dir == 'asc' {
            $greater: map-merge($greater, ($key: $map));
          } @else {
            $less: map-merge($less, ($key: $map));
          }
        }
      }

      $less: maps-sort($less, $keys...);
      $greater: maps-sort($greater, $keys...);

      @return map-merge(map-merge($less, $equal), $greater);

    } @else {

      $seed-map: nth($maps, ceil(length($maps) / 2));

      $seed-value: map-get-nested($seed-map, $keys...);

      @each $map in $maps {

        $curr-value: map-get-nested($map, $keys...);

        @if $curr-value == $seed-value {
          $equal: append($equal, $map);
        } @else if $curr-value < $seed-value {
          @if $maps-sort-dir == 'asc' {
            $less: append($less, $map);
          } @else {
            $greater: append($greater, $map);
          }
        } @else {
          @if $maps-sort-dir == 'asc' {
            $greater: append($greater, $map);
          } @else {
            $less: append($less, $map);
          }
        }
      }

      $less: maps-sort($less, $keys...);
      $greater: maps-sort($greater, $keys...);

      @return join(join($less, $equal), $greater);

    }
  }

  @return $maps;
}








//  _ _     _
// | (_)   | |
// | |_ ___| |_ ______ _ __ ___   __ _ _ __  ___
// | | / __| __|______| '_ ` _ \ / _` | '_ \/ __|
// | | \__ \ |_       | | | | | | (_| | |_) \__ \
// |_|_|___/\__|      |_| |_| |_|\__,_| .__/|___/
//                                    | |
//                                    |_|

/// Return list-map from `$list` and ensure input list-map is list-of-lists
/// @access public
/// @group list-map
/// @param {List} $list
/// @return {List-map}
@function list-map-check($list) {
  @if length($list) == 2 and length(nth($list, 1)) == 1 {
    @return append((), $list, 'comma');
  }

  @return $list;
}


/// Return comma-separated list of keys from list-map
/// Conformant with Ruby Sass `map-keys()`
/// @access public
/// @group list-map
/// @param {Arglist} $list - List-map
/// @return {List}
/// @require {function} list-map-check
/// @require {function} tuple-key
@function list-map-keys($list...) {
  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $output: ();

  @each $tuple in $list {
    $output: append($output, tuple-key($tuple), 'comma');
  }

  @return $output;
}


/// Return comma-separated list of values from list-map
/// Conformant with Ruby Sass `map-values()`
/// @access public
/// @group list-map
/// @param {Arglist} $list - List-map
/// @return {List}
/// @require {function} list-map-check
/// @require {function} tuple-value
@function list-map-values($list...) {
  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $output: ();

  @each $tuple in $list {
    $output: append($output, tuple-value($tuple), 'comma');
  }

  @return $output;
}


/// Check whether key exists in list-map at root level
/// Conformant with Ruby Sass `map-has-key()`
/// @access public
/// @group list-map
/// @param {List-map} $list - List-map
/// @param {*} $key - Key to check
/// @return {Bool}
/// @require {function} list-map-check
/// @require {function} tuple-key
@function list-map-has-key($list, $key) {
  $list: list-map-check($list);

  @each $tuple in $list {
    @if tuple-key($tuple) == $key {
      @return true;
    }
  }

  @return false;
}


/// Return value corresponding to key in list-map
/// Conformant with Ruby Sass `map-get()`
/// @access public
/// @group list-map
/// @param {List-map} $list - List-map
/// @param {*} $key - Key to fetch
/// @return {*} - Value mapped to `$key`
/// @require {function} list-map-check
/// @require {function} tuple-key
/// @require {function} tuple-value
@function list-map-get($list, $key) {
  $list: list-map-check($list);

  @each $tuple in $list {
    @if tuple-key($tuple) == $key {
      @return tuple-value($tuple);
    }
  }

  @return null;
}


/// Return a merge of second list-map in to first list-map
/// Conformant with Ruby Sass `map-merge()`
/// @access public
/// @group list-map
/// @param {List-map} $list1 - First list-map
/// @param {List-map} $list2 - Second list-map
/// @return {List-map}
/// @require {function} list-map-check
/// @require {function} list-map-keys
/// @require {function} tuple-key
@function list-map-merge($list1, $list2) {
  $list1: list-map-check($list1);
  $list2: list-map-check($list2);
  $keys1: list-map-keys($list1);

  @each $tuple in $list2 {
    $index: index($keys1, tuple-key($tuple));

    @if $index {
      $list1: set-nth($list1, $index, $tuple);
    } @else {
      $list1: append($list1, $tuple, 'comma');
    }
  }

  @return $list1;
}


/// Return list-map with tuples removed, according to keys (if found)
/// @access public
/// @group list-map
/// @param {List-map} $list - List-map
/// @param {Arglist} $keys - Keys to remove from `$list`
/// @return {List-map}
/// @require {function} list-map-check
/// @require {function} tuple-key
@function list-map-remove($list, $keys...) {
  $list: list-map-check($list);
  $output: ();

  @each $tuple in $list {
    @if not index($keys, tuple-key($tuple)) {
      $output: append($output, $tuple, 'comma');
    }
  }

  @return $output;
}


/// A *deep*, nested or chained version of `map-get()`
/// @access public
/// @group list-map
/// @param {List-map} $list - List-map
/// @param {Arglist} $keys - Keys to fetch
/// @return {*}
/// @require {function} list-map-get
@function list-map-get-nested($list, $keys...) {
  @each $key in $keys {
    @if type-of($list) != 'list' {
      @return $list;
    }

    $list: list-map-get($list, $key);
  }

  @return $list;
}


/// A *deep*, nested or chained version of `map-merge`; offers `map-set` syntax too
/// @access public
/// @group list-map
/// @param {List-map} $list - List-map
/// @param {Arglist} $args
/// @return {List-map}
/// @require {function} list-map-check
/// @require {function} list-map-merge
/// @require {function} list-map-get-nested
/// @require {function} slice
@function list-map-merge-nested($list, $kv...) {
  $list: list-map-check($list);
  $kv-length: length($kv);
  $key-length: $kv-length - 1;
  $value: nth($kv, $kv-length);
  $value-is-list: type-of($value) == 'list';

  @if $key-length == 0 {
    $value: list-map-merge($list, if($value-is-list, $value, append((), $value (), 'comma')));
  } @else {
    @for $i from if($value-is-list, 0, 1) through $key-length {
      $new: if($i == 0, $value, append((), nth($kv, $kv-length - $i) $value, 'comma'));
      $old: if($i == $key-length, $list, list-map-get-nested($list, slice($kv, 1, $key-length - $i)...) or ());
      $value: if(type-of($old) == 'list', list-map-merge($old, $new), $new);
    }
  }

  @return $value;
}




/// Return previous key from list-map
/// @access public
/// @group list-map
/// @param {List-map} $list - List-map
/// @param {*} $key - Pivot key
/// @return {*}
/// @require {function} list-map-check
/// @require {function} list-map-keys
@function list-map-prev-key($list, $key) {
  $list: list-map-check($list);
  $keys: list-map-keys($list);

  @return nth($keys, index($keys, $key) - 1);
}


/// Return next key from list-map
/// @access public
/// @group list-map
/// @param {List-map} $list - List-map
/// @param {*} $key - Pivot key
/// @return {*}
/// @require {function} list-map-check
/// @require {function} list-map-keys
@function list-map-next-key($list, $key) {
  $list: list-map-check($list);
  $keys: list-map-keys($list);

  @return nth($keys, index($keys, $key) + 1);
}


/// Return the string representation of a list-map
/// @access public
/// @group list-map
/// @param {Arglist} $list - List-map to inspect
/// @return {String}
/// @require {function} list-map-check
/// @require {function} list-map-keys
/// @require {function} list-map-inspect
/// @require {function} tuple-key
/// @require {function} tuple-values
@function list-map-inspect($list...) {
  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $output: '(';
  $i: 1;

  @each $tuple in $list {
    @if length($tuple) != 2 {
      $output: $output + '#{$tuple}';
    } @else {
      $key: tuple-key($tuple);
      $value: tuple-value($tuple);
      $output: $output + '#{$key} ' + if(type-of($value) == 'list', '#{list-map-inspect($value)}', '#{$value}');
    }

    @if $i < length(list-map-keys($list)) {
      $output: $output + ', ';
    }

    $i: $i + 1;
  }

  @return $output + ')';
}


/// Return the string representation of a list-map with indents and line breaks
/// @access public
/// @group list-map
/// @param {List-map} $list - List-map to inspect
/// @param {Number} $level [1] - Internal variable, **do not edit**
/// @require {function} list-map-check
/// @require {function} list-map-keys
@function list-map-pretty($list, $level: 1) {
  $tab: '  ';
  $cr: '
';
  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $indent: $tab; $outdent: $tab;

  @for $n from 1 through $level {
    $indent: $indent + $tab;
  }

  @for $n from 1 through $level - 1 {
    $outdent: $outdent + $tab;
  }

  $output: '(' + $cr + $indent;
  $i: 1;

  @each $tuple in $list {
    @if length($tuple) != 2 {
      $output: $output + '#{$tuple}';
    } @else {
      $key: nth($tuple, 1); $value: nth($tuple, 2);
      @if type-of($value) == 'list' {
        $output: $output + '#{$key} #{list-map-pretty($value, $level+1)}';
      } @else {
        $output: $output + '#{$key} #{$value}';
      }
    }

    @if $i < length(list-map-keys($list)) {
      $output: $output + ',' + $cr + $indent;
    }

    $i: $i + 1;
  }

  @return $output + $cr + $outdent + ')';
}


/// Global sort direction: either `asc` or `desc`
/// @access public
/// @group list-map
$list-map-sort-dir: 'asc';


/// Return sorted list-map, based on values at given key(s)
/// @access public
/// @group list-map
/// @param {List-map} $list-map - List-map to sort
/// @param {Arglist} $keys - Keys to use for sorting
/// @return {List-map}
/// @require {function} list-map-check
/// @require {function} list-map-get-nested
@function list-map-sort($list-map, $keys...) {
  @if length($keys) < 1 {
    @return $list-map;
  }

  $list-map: list-map-check($list-map);

  @if length($list-map) > 1 {
    $less: ();
    $equal: ();
    $greater: ();
    $seed: nth($list-map, ceil(length($list-map) / 2));
    $seed-value: list-map-get-nested(nth($seed, 2), $keys...);

    @each $item in $list-map {
      $item-value: list-map-get-nested(nth($item, 2), $keys...);

      @if $list-map-sort-dir == 'asc' {
        @if $item-value == $seed-value {
          $equal: append($equal, $item, 'comma');
        } @else if $item-value < $seed-value {
          $less: append($less, $item, 'comma');
        } @else {
          $greater: append($greater, $item, 'comma');
        }
      } @else {
        @if $item-value == $seed-value {
          $equal: append($equal, $item, 'comma');
        } @else if $item-value > $seed-value {
          $less: append($less, $item, 'comma');
        } @else {
          $greater: append($greater, $item, 'comma');
        }
      }
    }

    @return join(join(map-sort($less, $keys...), $equal), list-map-sort($greater, $keys...));
  }

  @return $list-map;
}


/// Return JSON string representation of a list-map
/// @access public
/// @group list-map
/// @param {Arglist} $list - List-map
/// @return {String} - JSON string
/// @require {function} list-map-check
/// @require {function} list-map-keys
@function list-map-json($list...) {
  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $output: '{ ';
  $i: 1;

  @each $tuple in $list {
    @if length($tuple) != 2 {
      $output: $output + '#{$tuple}';
    } @else {
      $key: nth($tuple, 1);
      $value: nth($tuple, 2);

      @if type-of($value) == 'list' {
        $output: $output + '"#{$key}": #{list-map-json($value)}';
      } @else if type-of($value) == 'number' {
        $value: if(unitless($value), $value, '"#{$value}"');
        $output: $output + '"#{$key}": #{$value}';
      } @else {
        $value: if(type-of($value) == 'bool', $value, '"#{$value}"');
        $output: $output + '"#{$key}": #{$value}';
      }
    }

    @if $i < length(list-map-keys($list)) {
      $output: $output + ', ';
    }

    $i: $i + 1;
  }

  @return $output + ' }';
}

//        _ _
//       | (_)
//   __ _| |_  __ _ ___  ___  ___
//  / _` | | |/ _` / __|/ _ \/ __|
// | (_| | | | (_| \__ \  __/\__ \
//  \__,_|_|_|\__,_|___/\___||___/

/////////
// GET //
/////////

/// 'z' nested-getter function alias
/// @access public
/// @group aliases
/// @alias map-get-nested
/// @require {function} map-get-nested
@function map-get-z($args...) { @return map-get-nested($args...); }

/// 'deep' nested-getter function alias
/// @access public
/// @group aliases
/// @alias map-get-nested
/// @require {function} map-get-nested
@function map-get-deep($args...) { @return map-get-nested($args...); }

/// universal [nested-]getter function alias (any depth)
/// @access public
/// @group aliases
/// @alias map-get-nested
/// @require {function} map-get-nested
@function get($args...) { @return map-get-nested($args...); }

///////////
// MERGE //
///////////

/// 'z' nested-merger function alias
/// @access public
/// @group aliases
/// @alias map-merge-nested
/// @require {function} map-merge-nested
@function map-merge-z($args...) { @return map-merge-nested($args...); }

/// 'deep' nested-merger function alias
/// @access public
/// @group aliases
/// @alias map-merge-nested
/// @require {function} map-merge-nested
@function map-merge-deep($args...) { @return map-merge-nested($args...); }

/// universal [nested-]merger function alias (any depth)
/// @access public
/// @group aliases
/// @alias map-merge-nested
/// @require {function} map-merge-nested
@function merge($args...) { @return map-merge-nested($args...); }

/////////
// SET //
/////////

/// nested-setter function alias
/// @access public
/// @group maps
/// @alias map-merge-nested
/// @require {function} map-merge-nested
@function map-set-nested($args...) { @return map-merge-nested($args...); }

/// 'z' nested-setter function alias
/// @access public
/// @group aliases
/// @alias map-merge-nested
/// @require {function} map-merge-nested
@function map-set-z($args...) { @return map-merge-nested($args...); }

/// 'deep' nested-setter function alias
/// @access public
/// @group aliases
/// @alias map-merge-nested
/// @require {function} map-merge-nested
@function map-set-deep($args...) { @return map-merge-nested($args...); }

/// universal [nested-]setter function alias (any depth)
/// @access public
/// @group aliases
/// @alias map-merge-nested
/// @require {function} map-merge-nested
@function set($args...) { @return map-merge-nested($args...); }

//////////////
// LISTMAPS //
//////////////

/// List-map getter function
/// @access public
/// @group aliases
/// @alias list-map-get-nested
/// @require {function} list-map-get-nested
@function list-get($args...) { @return list-map-get-nested($args...); }


/// List-map setter function
/// @access public
/// @group aliases
/// @alias list-map-merge-nested
/// @require {function} list-map-merge-nested
@function list-merge($args...) { @return list-map-merge-nested($args...); }


/// List-map setter function
/// @access public
/// @group aliases
/// @alias list-map-merge-nested
/// @require {function} list-map-merge-nested
@function list-set($args...) { @return list-map-merge-nested($args...); }

//                     _
//                    | |
//  _ __ ___  ___  ___| |_ ___
// | '__/ _ \/ __|/ _ \ __/ __|
// | | |  __/\__ \  __/ |_\__ \
// |_|  \___||___/\___|\__|___/

@mixin resets() {
  @include reset-n3();
  @include reset-ln();
}

@mixin reset-n3(){
  // normalize.css v3.0.2 | MIT License | git.io/normalize
  html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
  body{margin:0}
  article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}
  audio,canvas,progress,video{display:inline-block;vertical-align:baseline}
  audio:not([controls]){display:none;height:0}
  [hidden],template{display:none}
  a{background-color:transparent}
  a:active,a:hover{outline:0}
  abbr[title]{border-bottom:1px dotted}
  b,strong{font-weight:bold}
  dfn{font-style:italic}
  h1{font-size:2em;margin:.67em 0}
  mark{background:#ff0;color:#000}
  small{font-size:80%}
  sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
  sup{top:-0.5em}
  sub{bottom:-0.25em}
  img{border:0}
  svg:not(:root){overflow:hidden}
  figure{margin:1em 40px}
  hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
  pre{overflow:auto}
  code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}
  button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}
  button{overflow:visible}
  button,select{text-transform:none}
  button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
  button[disabled],html input[disabled]{cursor:default}
  button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
  input{line-height:normal}
  input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
  input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}
  input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
  input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
  fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
  legend{border:0;padding:0}
  textarea{overflow:auto}
  optgroup{font-weight:bold}
  table{border-collapse:collapse;border-spacing:0}
  td,th{padding:0}
}

@mixin reset-ln(){
  *, *:before, *:after { box-sizing: inherit; } // inherit box sizing (from html)
  html, body { height: 100%; } // set height to 100%; needed for various shit
  html {
    box-sizing: border-box; // will be inherited by all elements
    -webkit-font-smoothing: antialiased; // unify font rendering
    -moz-osx-font-smoothing: grayscale; // ''
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0); // remove webkit tap highlight color
    text-rendering: optimizespeed; // fixes a webkit bug re: optimizelegibility?
  }
}

//                     _ _
//                    | (_)
//  _ __ ___   ___  __| |_  __ _
// | '_ ` _ \ / _ \/ _` | |/ _` |
// | | | | | |  __/ (_| | | (_| |
// |_| |_| |_|\___|\__,_|_|\__,_|

$base: () !default;
$base-orig: ();

$media: (
  alpha: (breakpoint: 20em),
  beta: (breakpoint: 30em),
  gamma: (breakpoint: 48em),
  delta: (breakpoint: 64em),
  epsilon: (breakpoint: 80em)
) !default;
$media-orig: ();

@mixin parse-media($output: true) {

  // backup and merge against defaults
  $base-orig: $base;

  $base: map-merge((
      font-size: 16px,
      font-size-mod: 1.5,
      line-height: 1.5,
      margin-x: 1rem,
      margin-x-mod: 1.5,
      margin-y: 1.5rem,
      margin-y-mod: 1.5,
      body-top: 1rem,
      body-right: 1rem,
      body-bottom: 1rem,
      body-left: 1rem,
    ), $base);

  // correct for font-size and line-height units/non-units
  $font-size: map-get($base, 'font-size');
  $line-height: map-get($base, 'line-height');
  @if unit($font-size) == 'px' { $font-size: $font-size / 16px; }
  @else { $font-size: assert($font-size, rem); }
  @if unit($line-height) == 'px' { $line-height: $line-height / $font-size; }
  $html-scale: strip($font-size);
  // .. and for pixel-united other values
  $corrected-values: ('html-scale': $html-scale, 'font-size': $font-size, 'line-height': $line-height);
  @each $key, $value in map-remove($base, 'font-size', 'line-height') {
    @if unit($value) == 'px' { $corrected-values: map-merge($corrected-values, ($key: $value / $font-size * 1rem)); }
  }

  // merge it all back to default
  $base: map-merge($base, $corrected-values);

  @if $output {

    /////////////////////
    // default-medium //
    /////////////////////

    // JSON format string output for pickup in JS

    $medium-key-list: ();
    @each $key in map-keys($media) {
      $medium-key-list: append($medium-key-list, quote($key), 'comma');
    }

    body::before {
      width: 0;
      height: 0;
      display: block;
      overflow: hidden;
      content: '{ "current" : "default", "all": ["#{$medium-key-list}"] }';
    }

    // nb: some approaches recommend using html instead of head here, and then resetting real font-family on body
    head { font-family: '{ "current" : "default", "all": ["#{$medium-key-list}"] }'; }

    .util--medium { width: 0; transition: width 1ms; }

    // styles

    html { font-size: percentage(map-get($base, 'html-scale')); }

    body {
      line-height: map-get($base, 'line-height');
      padding-top: map-get($base, 'body-top');
      padding-bottom: map-get($base, 'body-bottom');
    }
  }

  //////////////
  // media //
  //////////////

  // backup data first
  $media-orig: $media;

  // TODO: add a conditional re-assignment here, rather than the default thing above

  @if $media != () {

    // maintain a reference-medium upon which to merge each medium in media
    $reference-medium: $base;

    // collect and sort the breakpoint media
    $sorted-media: maps-sort(maps-collect($media, 'breakpoint'), 'breakpoint');

    @each $medium-alias, $medium in $sorted-media {

      // merge medium to reference
      $reference-medium: map-merge($reference-medium, $medium);

      // correct for font-size and line-height units/non-units
      $font-size: map-get($reference-medium, 'font-size');
      $line-height: map-get($reference-medium, 'line-height');
      @if unit($font-size) == 'px' { $font-size: $font-size / 16px; }
      @else { $font-size: assert($font-size, rem); }
      @if unit($line-height) == 'px' { $line-height: $line-height / $font-size; }
      $html-scale: strip($font-size);
      // ..and for pixel-united other values
      $corrected-values: ('html-scale': $html-scale, 'font-size': $font-size, 'line-height': $line-height);
      @each $key, $value in map-remove($reference-medium, 'font-size', 'breakpoint', 'line-height') {
        @if unit($value) == 'px' { $corrected-values: map-merge($corrected-values, ($key: $value / $font-size * 1rem)); }
      }
      // merge corrections back to reference
      $reference-medium: map-merge($reference-medium, $corrected-values);

      // merge some additions to reference
      $device-width: assert(map-get($reference-medium, 'breakpoint') / $html-scale, rem);
      $content-width: $device-width - (map-get($reference-medium, 'body-left') + map-get($reference-medium, 'body-right'));
      $reference-medium: map-merge($reference-medium, ('device-width': $device-width, 'content-width': $content-width));

      // merge reference back to master
      $media: map-merge($media, ($medium-alias: $reference-medium));

      @if $output {
        $font-size: map-get($medium, 'font-size');
        $line-height: map-get($medium, 'line-height');
        $body-top: map-get($medium, 'body-top');
        $body-bottom: map-get($medium, 'body-bottom');

        @include medium($medium-alias) {

          body::before { content: '{ "current" : "#{$medium-alias}", "all": ["#{$medium-key-list}"] }'; }
          head { font-family: '{ "current" : "#{$medium-alias}", "all": ["#{$medium-key-list}"] }'; }

          .util--medium { width: index(map-keys($media), $medium-alias) * 1px; }

          // output CSS if spec'd by user

          @if $font-size { html { font-size: percentage(map-get($reference-medium, 'html-scale')); } }
          @if $line-height { body { line-height: map-get($reference-medium, 'line-height'); } }
          @if $body-top { body { margin-top: map-get($reference-medium, 'body-top'); } }
          @if $body-bottom { body { margin-bottom: map-get($reference-medium, 'body-bottom'); } }

        }
      }
    }
  }
}


//                     _ _                    _   _ _
//                    | (_)                  | | (_) |
//  _ __ ___   ___  __| |_  __ _ ______ _   _| |_ _| |
// | '_ ` _ \ / _ \/ _` | |/ _` |______| | | | __| | |
// | | | | | |  __/ (_| | | (_| |      | |_| | |_| | |
// |_| |_| |_|\___|\__,_|_|\__,_|       \__,_|\__|_|_|

$current-medium-alias: null;

// [width] medium string function
@function medium-string($alias1: null, $alias2: null) {
  @return 'screen'
    + if($alias1, ' and (min-width: #{get($media, $alias1, breakpoint)})', '')
    + if($alias2, ' and (max-width: #{get($media, $alias2, breakpoint) - 0.001})', '');
}

// retrieve current width medium object
@function medium($medium-alias: $current-medium-alias) {
  $medium: null;
  @if $medium-alias { $medium: map-get($media, $medium-alias); }
  @return if($medium, $medium, $base);
}

// function to retrieve current medium-data-object based on $current-medium-alias
@function medium-orig($medium-alias: $current-medium-alias) {
  $medium: null;
  @if $medium-alias { $medium: map-get($media-orig, $medium-alias); }
  @return if($medium, $medium, $base);
}

// function to retrieve value for current medium
@function medium-value($key, $alias: $current-medium-alias) {
  @return map-get(medium($alias), $key);
}

// ==========================================================================
// medium() mixins
// ==========================================================================

// mixin to output width media medium
@mixin medium($aliases...) {

  // save the medium
  $prev-medium-alias: $current-medium-alias;

  // get the current alias or at least the previous one if in max-width medium
  @if length($aliases) > 0 {
    $current-medium-alias: nth($aliases, 1) or map-prev-key($media, nth($aliases, 2));
  }

  // run the content in medium
  @media #{medium-string($aliases...)} { @content }

  // reset the medium (no nesting; could just reset to null)
  $current-medium-alias: $prev-medium-alias;
}

// default hd ratio
$medium-hd-ratio: (3,2);

// hd media query
@mixin hd($aliases...) {

  $n: nth($medium-hd-ratio, 1);
  $d: nth($medium-hd-ratio, 2);
  $ratio: $n/$d;

  // save the medium
  $prev-medium-alias: $current-medium-alias;

  // get the current alias or at least the previous one if in max-width medium
  @if length($aliases) > 0 {
    $current-medium-alias: nth($aliases, 1) or map-prev-key($media, nth($aliases, 2));
  }

  // run the content in medium
  @media screen and
    (-webkit-min-device-pixel-ratio: $ratio),
    (min--moz-device-pixel-ratio: $ratio),
    (-o-min-device-pixel-ratio: #{$n}/#{$d}),
    (min-device-pixel-ratio: $ratio),
    (min-resolution: $ratio * 96dpi),
    (min-resolution: $ratio * 1dppx) {
    @content;
  }

  // reset the medium (no nesting; could just reset to null)
  $current-medium-alias: $prev-medium-alias;
}

// multi width medium -- combines both medium-each() and medium-for()
@mixin each-medium($options:()) {

  // get 'from', 'to' and 'for'
  $from: get($options, 'from');
  $to: get($options, 'to');
  $for: get($options, 'for');

  // correct 'for' options
  @if contains(root base default, $from) { $from: null; }
  @if $for {
    @if contains($for, margin-y) { $for: append($for, margin-y-modulation)}
    @if contains($for, margin-x) { $for: append($for, margin-x-modulation)}
    @if contains($for, font-size) { $for: append($for, font-size-modulation); }
    @if contains($for, trim) { $for: append($for, line-height); }
    @if contains($for, line-height) { $for: append($for, trim); }
  }

  // output the @content raw, if $from is null
  @if not $from { @content; }

  // determine other referenced media
  $medium-aliases: map-keys($media);
  $sliced-aliases: slice($medium-aliases,
      if($from, index($medium-aliases, $from), 1),
      if($to, index($medium-aliases, $to) - 1, length($medium-aliases)));

  // conditional per-medium actions
  @each $medium-alias in $sliced-aliases {
    @if not $for { @include medium($medium-alias) { @content; } }
    @else if contains-any(keys(medium-orig($medium-alias)), $for) {
      @include medium($medium-alias) { @content; }
    }
  }
}


// ==========================================================================
// medium-related units
// ==========================================================================

// unit preference
$media-use-rems: true;

// function to convert value(s) to rem, following medium scale
@function rem($values...) {
  @if $values == null { @return null; }
  $scale: medium-value('html-scale');
  $unit: if($media-use-rems, 'rem', 'em');
  $result: ();
  @each $value in $values {
    @if index('rem' 'em', unit($value)) { $result: append($result, assert($value, $unit), 'space'); }
    @else { $result: append($result, assert($value / $scale / 16, $unit), 'space'); }
  }
  @return if(length($result) > 1, $result, nth($result, 1));
}

// function to convert value(s) to px, following medium scale
@function px($values...) {
  @if $values == null { @return null; }
  $scale: medium-value('html-scale');
  $result: ();
  @each $value in $values {
    @if unit($value) == 'px' { $result: append($result, $value, 'space'); }
    @else { $result: append($result, assert($value * $scale * 16, 'px'), 'space'); }
  }
  @return if(length($result) > 1, $result, nth($result, 1));
}


// layout fundaments
$layout-grid-float: left !default; // right | left | false
$layout-wrap-alignment: false !default; // right | left | false

@mixin parse-layout($output: true){

  @if $output {

    $margin-x: 2rem;
    $margin-y: 2rem;
    $body-right: 2rem;
    $body-left: 2rem;

    // get dimensions from '$base' if it exists
    @if variable-exists('base') {
      $margin-x: get($base, 'margin-x');
      $margin-y: get($base, 'margin-y');
      $body-right: get($base, 'body-right');
      $body-left: get($base, 'body-left');
    }

    // SPREAD, WRAP, GRID, CELL
    %spread, .spread, [class*='spread--'], [l='spread'] {
      padding-left: $body-left;
      padding-right: $body-right;
    }
    %wrap, .wrap, [class*='wrap--'], [l='wrap'] {
      margin-left: auto;
      margin-right: auto;
    }
    %section, .section, [class*='section--'], [l='section'] {
      padding-top: $margin-y / 2;
      padding-bottom: $margin-y / 2;
    }
    %grid, .grid, [class*='grid--'], [l='grid'] {
      width: calc(100% + #{$margin-x});
      margin-left: $margin-x / -2;
      margin-right: $margin-x / -2;
    }
    %cell, .cell, [class*='cell--'], [l='cell'] {
      display: block; float: left;
      width: 100%;
      padding-left: $margin-x / 2;
      padding-right: $margin-x / 2;
    }

    @if variable-exists('media') {

      @each $alias, $medium in $media {
        $margin-x: get($medium, 'margin-x');
        $margin-y: get($medium, 'margin-y');
        $body-right: get($medium, 'body-right');
        $body-left: get($medium, 'body-left');

        @include medium($alias) {

          $orig: medium-orig();

          // SPREAD
          %spread, .spread, [class*='spread--'], [l='spread'] {
            @if map-has-key($orig, 'body-left') { padding-left: $body-left; }
            @if map-has-key($orig, 'body-right') { padding-right: $body-right; }
          }

          // SECTION
          @if map-has-key($orig, 'margin-y') {
            %section, .section, [class*='section--'], [l='section'] {
              padding-top: $margin-y / 2;
              padding-bottom: $margin-y / 2;
            }
          }

          // WRAP
          $keys: map-keys($media); $wrap-each-to: (); $wrap-each-from: ();
          @each $alias in slice($keys, 1, index($keys, $alias)) {
            $wrap-each-from: append($wrap-each-from, unquote('.wrap--each_from--#{$alias}'), 'comma');
          }
          @each $alias in slice($keys, index($keys, $alias), length($keys)) {
            $wrap-each-to: append($wrap-each-to, unquote('.wrap--each_to--#{$alias}'), 'comma');
          }
          .wrap--#{$alias} { max-width: medium-value('content-width', $alias); }
          .wrap--each, #{$wrap-each-from}, #{$wrap-each-to} { max-width: medium-value('content-width'); }

          // GRID, CELL
          @if map-has-key($orig, 'margin-x') {
            %grid, .grid, [class*='grid--'], [l='grid'] {
              width: calc(100% + #{$margin-x});
              margin-left: $margin-x / -2;
              margin-right: $margin-x / -2;
            }
            %cell, .cell, [class*='cell--'], [l='cell'] {
              padding-left: $margin-x / 2;
              padding-right: $margin-x / 2;
            }
          }
        }
      }
    }
  }

}

//       _     _ _     _        _                         _
//      | |   (_) |   | |      | |                       | |
//   ___| |__  _| | __| |______| | __ _ _   _  ___  _   _| |_
//  / __| '_ \| | |/ _` |______| |/ _` | | | |/ _ \| | | | __|
// | (__| | | | | | (_| |      | | (_| | |_| | (_) | |_| | |_
//  \___|_| |_|_|_|\__,_|      |_|\__,_|\__, |\___/ \__,_|\__|
//                                       __/ |
//                                      |___/

// RE peudo elements

// http://nicolasgallagher.com/an-introduction-to-css-pseudo-element-hacks/
// http://css-tricks.com/pseudo-element-roundup/

// RE table display

// table-layout - CSS | MDN | https://developer.mozilla.org/en-US/docs/Web/CSS/table-layout
// Fixed Table Layouts | CSS-Tricks | http://css-tricks.com/fixing-tables-long-strings/
// ungrid - the simplest responsive css grid | https://chrisnager.github.io/ungrid/
// Pure CSS, equal-width navigation tabs | http://jsfiddle.net/csswizardry/zfSt4/


@function child-selector($selector) {
  @if str-index($selector, '&'){
    @return '#{$selector}';
  } @else {
    @return '& > #{$selector}';
  }
}

@mixin child-layout($selector, $type, $options...) {

  ///////////
  // TABLE //
  ///////////

  @if index(table-cell table-row cell row, $type) {
    width: 100%; // force auto size of children
    display: table;
    table-layout: fixed;
    border-collapse: collapse;
    #{child-selector($selector)} {
      @if index(table-row row, $type) {
        display: table-row;
        height: auto; // base setting
        @if index($options, center) or index($options, centre) { text-align: center; }
        @else if index($options, right) { text-align: right;}
        @else { text-align: left; }
      }
      @else {
        display: table-cell;
        width: auto; // base setting
        @if index($options, bottom) { vertical-align: bottom; }
        @else if index($options, middle) { vertical-align: middle;}
        @else { vertical-align: top; }
      }
      overflow: hidden;
      @content;
    }
  }

  //////////////////
  // INLINE BLOCK //
  //////////////////

  @else if index(inline-block iblock ib, $type) {
    font-size: 0px;
    @if index($options, justify) {
      text-align: justify;
      &:after, #{child-selector($selector)} {
        display: inline-block;
        max-width: 100%; // ff bug
        @if index($options, bottom) { vertical-align: bottom; }
        @else if index($options, middle) { vertical-align: middle;}
        @else { vertical-align: top; }
      }
      &:after {
        content: '';
        width: 100%;
      }
      #{child-selector($selector)} {
        font-size: 1rem;
        @content;
      }
    }
    @else {
      &:before, #{child-selector($selector)} {
        display: inline-block;
        max-width: 100%; // ff bug
        @if index($options, bottom) { vertical-align: bottom; }
        @else if index($options, middle) { vertical-align: middle;}
        @else { vertical-align: top; }
      }
      &:before {
        content: '';
        height: 100%;
      }
      #{child-selector($selector)} {
        font-size: 1rem;
        @content;
      }
      @if index($options, center) or index($options, centre) { text-align: center; }
      @else if index($options, right) { text-align: right;}
      @else { text-align: left; }
    }
  }
}

// @mixin col($span, $margins-and-edge...) {}
// span: 1 or 2 item list
// margins: list-map with right and/or left args
// edge: cycle [d], alpha, omega, both
// .test {
//   @include col(1 2, right 1, left -1);
//   @include col(1 2, cycle);
//   @include col(1 2, right 1, cycle);
//   @include col(1 1)
//   // if no span argp
// }




// @mixin cell2($span, $margins-and-edge...){
//   $margins: null; $edge: cycle;
//   // $right: null; $left: null;
//   $args-length: length($margins-and-edge);
//   @if $args-length > 0 {
//     $margins: slice($margins-and-edge, 1, $args-length - 1);
//     $edge: nth($margins-and-edge, $args-length);
//     $right: list-get($margins, right);
//     $left: list-get($margins, left);
//   }
//   $gutter: medium-value('margin-x');

//   $span-n: nth($span, 1);
//   $span-d: nth($span, 2);
//   width: calc((100% + #{$gutter}) * (#{$span-n} / #{$span-d}));

//   $left-n: nth($left, 1);
//   $left-d: if(length($left) > 1, nth($left, 2), $span-d);
//   $left-width: if($left, '(100% + #{$gutter}) * (#{$left-n} / #{$left-d})', '0%');

//   $right-n: nth($right, 1);
//   $right-d: if(length($right) > 1, nth($right, 2), $span-d);
//   $right-width: if($right, '(100% + #{$gutter}) * (#{$right-n} / #{$right-d})', '0%');

//   $cycle-d: if(length($edge) > 1, nth($edge, 2), $span-d);

//   $is-alpha: $edge == alpha;
//   $is-omega: $edge == omega;
//   $is-cycle: nth($edge, 1) == cycle;

//   $left-corr: if($is-alpha or $is-cycle, '#{$gutter / -2}', '0');
//   $right-corr: if($is-omega or $is-cycle, '#{$gutter / -2}', '0');

//   @if index(out outside, $left-n) {
//     margin-left: calc(#{$left-corr} + (100% + #{$gutter}) * (-#{$span-n} / #{$span-d}));
//   }
//   @else if index(out outside, $right-n) {
//     margin-right: calc(#{$right-corr} + #{$right-width});
//   }
//   @else if $cycle-d == 1 {
//     // require both corrected
//     margin-left: calc(#{$left-corr} + #{$left-width});
//     margin-right: calc(#{$right-corr} + #{$right-width});
//   }
//   @else if $is-cycle and $cycle-d > 1 {
//     // output both uncorrected if given
//     margin-right: if($right, calc(#{$right-width}), 0);
//     margin-left: if($left, calc(#{$left-width}), 0);
//     // @if $left { margin-left: calc(#{$left-width}); }
//     // @if $right { margin-right: calc(#{$right-width}); }
//     // require both corrected for nth-child cases
//     &:nth-child(#{$cycle-d}n+1){
//       @if $layout-grid-float { clear: left; } // clear if layout is float
//       margin-left: calc(#{$left-corr} + #{$left-width});
//     }
//     &:nth-child(#{$cycle-d}n){
//       margin-right: calc(#{$right-corr} + #{$right-width});
//     }
//   }
//   @else if $is-alpha {
//     // clear if layout is float
//     @if $layout-grid-float { clear: left; }
//     // require left corrected
//     margin-left: calc(#{$left-corr} + #{$left-width});
//     // output right uncorrected if given, or 0
//     margin-right: if($right, calc(#{$right-width}), 0);
//   }
//   @else if $is-omega {
//     // require right corrected
//     margin-right: calc(#{$right-corr} + #{$right-width});
//     // output left uncorrected if given, or 0
//     margin-left: if($left, calc(#{$left-width}), 0);
//   }
//   @else {
//     // output both uncorrected if given, or 0
//     margin-right: if($right, calc(#{$right-width}), 0);
//     margin-left: if($left, calc(#{$left-width}), 0);
//     // @if $left { margin-left: calc(#{$left-width}); }
//     // @if $right { margin-right: calc(#{$right-width}); }
//     // require both corrected for first-/last-child cases
//     &:first-child, &.alpha { margin-left: calc(#{$gutter / -2} + #{$left-width}); }
//     &:last-child, &.omega { margin-right: calc(#{$gutter / -2} + #{$right-width}); }

//   }


//   .debug {
//     span: $span;
//     right: $right;
//     right-width: $right-width;
//     left: $left-width;
//     edge: $edge;
//     cycle-d: $cycle-d;
//   }

// }

// @mixin cell($spec: ()) {

//   $span: map-get($spec, span);
//   $left: map-get($spec, left);
//   $right: map-get($spec, right);
//   $edge: map-get($spec, edge) or map-get($spec, edges) or cycle;

//   $is-alpha: $edge == alpha;
//   $is-omega: $edge == omega;
//   $is-both: $edge == both;
//   $is-cycle: nth($edge, 1) == cycle;

//   $span-n: nth($span, 1);
//   $span-d: nth($span, 2);
//   width: calc((100% + #{$gutter}) * (#{$span-n} / #{$span-d}));

//   $left-n: nth($left, 1);
//   $left-d: if(length($left) > 1, nth($left, 2), $span-d);
//   $left-width: if($left, '(100% + #{$gutter}) * (#{$left-n} / #{$left-d})', '0%');

//   $right-n: nth($right, 1);
//   $right-d: if(length($right) > 1, nth($right, 2), $span-d);
//   $right-width: if($right, '(100% + #{$gutter}) * (#{$right-n} / #{$right-d})', '0%');

//   $left-corr: if($is-alpha or $is-both or $is-cycle, '#{$gutter / -2}', '0');
//   $right-corr: if($is-omega or $is-both or $is-cycle, '#{$gutter / -2}', '0');

//   @if index(out outside, $left-n) {
//     margin-left: calc(#{$left-corr} + (100% + #{$gutter}) * (-#{$span-n} / #{$span-d}));
//     // margin-right: 100%;
//     // margin-bottom: -100%;
//   }
//   @else if index(out outside, $right-n) {
//     margin-right: calc(#{$right-corr} + #{$right-width});
//     // margin-left: 100%;
//     // margin-bottom: -100%;
//   }
//   @else if $is-cycle and $cycle-d > 1 {
//     // output both uncorrected if given
//     // require both corrected for nth-child cases
//     @if $left { margin-left: calc(#{$left-width}); }
//     @if $right { margin-right: calc(#{$right-width}); }
//     &:nth-child(#{$cycle-d}n+1){
//       @if $float { clear: left; } // clear if layout is float
//       margin-left: calc(#{$left-corr} + #{$left-width});
//     }
//     &:nth-child(#{$cycle-d}n){
//       margin-right: calc(#{$right-corr} + #{$right-width});
//     }
//   }
//   @else if $cycle-d == 1 or $is-both {
//     // require both corrected
//     margin-left: calc(#{$left-corr} + #{$left-width});
//     margin-right: calc(#{$right-corr} + #{$right-width});
//   }
//   @else if $is-alpha {
//     // require left corrected; output right if given
//     @if $float { clear: left; } // clear if layout is float
//     margin-left: calc(#{$left-corr} + #{$left-width});
//     @if $right { margin-right: calc(#{$right-width}); }
//   }
//   @else if $is-omega {
//     // require right corrected; output left if given
//     margin-right: calc(#{$right-corr} + #{$right-width});
//     @if $left { margin-left: calc(#{$left-width}); }
//   }
//   @else {
//     // output both uncorrected if given
//     // require both corrected for first-/last-child cases
//     @if $left { margin-left: calc(#{$left-width}); }
//     @if $right { margin-right: calc(#{$right-width}); }
//     &:first-child, &.alpha { margin-left: calc(#{$gutter / -2} + #{$left-width}); }
//     &:last-child, &.omega { margin-right: calc(#{$gutter / -2} + #{$right-width}); }

//   }
// }



//  _                                           _
// | |                                         | |
// | |_ _   _ _ __   ___   __ _ _ __ __ _ _ __ | |__  _   _
// | __| | | | '_ \ / _ \ / _` | '__/ _` | '_ \| '_ \| | | |
// | |_| |_| | |_) | (_) | (_| | | | (_| | |_) | | | | |_| |
//  \__|\__, | .__/ \___/ \__, |_|  \__,_| .__/|_| |_|\__, |
//       __/ | |           __/ |         | |           __/ |
//      |___/|_|          |___/          |_|          |___/

@function mscale($index, $factor, $spread) { @return pow($factor, $index/$spread); }

$font-size: 20px;
$font-size-mod: 2;
$margin-x-mod: 1.5;
$margin-y-mod: 1.5;
$margin-x: 1rem;
$margin-y: 2rem;

@function scale($index, $basis: 10) {
  $factor: $margin-x-mod;
  $spread: ceil($basis/6);
  @return pow($factor, $index/$spread);
}

@function margin-x($index: 0, $basis: 10) {
  $factor: $margin-x-mod;
  $spread: ceil($basis/6);
  @return pow($factor, $index/$spread) * $margin-x;
}

@function margin-y($index: 0, $basis: 10) {
  $factor: $margin-y-mod;
  $spread: ceil($basis/6);
  @return pow($factor, $index/$spread) * $margin-y;
}

@function size($index: 0, $basis: 10) {
  $factor: $font-size-mod;
  $spread: ceil($basis/6);
  @return pow($factor, $index/$spread) * $font-size;
}

// .test {
//   font-size: size(0);
//   font-size: size(1);
//   font-size: size(2);
//   font-size: size(3);
//   font-size: size(4);
//   font-size: size(5);

//   margin: margin-y() margin-x();
//   margin: margin-y() margin-x(1);
//   margin: margin-y() margin-x(2);
//   margin: margin-y() margin-x(3);
//   margin: margin-y() margin-x(4);
//   margin: margin-y() margin-x(5);

// }
