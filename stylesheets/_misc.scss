//            _
//           (_)
//  _ __ ___  _ ___  ___ ___ ___
// | '_ ` _ \| / __|/ __/ __/ __|
// | | | | | | \__ \ (__\__ \__ \
// |_| |_| |_|_|___/\___|___/___/

// output stringified number w/ suffix e.g. 1st 2nd 3rd 4th
// not compatible with libsass
// @function enum($n) {
//   $h: abs($n) % 100; $t: $h % 10;
//   @if $h > 3 and $h < 21 { @return #{$n}th; }
//   @return #{$n}#{if($h == 1, 'st', if($t == 2, 'nd', if($t == 3, 'rd', 'th')))};
// }

@function opposite($dirs...) {
  @if length($dirs) == 1 and type-of(nth($dirs, 1)) == 'list' { @return opposite(nth($dirs, 1)...); }
  $out: (); $sep: list-separator($dirs);
  $opposites: ('top': bottom, 'right': left, 'bottom': top, 'left': right, 'ltr': rtl, 'rtl': ltr);
  @each $dir in $dirs {
    $opposite: if(type-of($dir) != 'list', map-get($opposites, $dir), opposite($dir...));
    @if $opposite {$out: append($out, $opposite, $sep); } }
  @return $out;
}

@mixin adjacent($siblings, $items) {
  $out: '';
  @for $k from 1 through length($items) {
    @for $n from 1 through length($siblings) {
      $out: if(
        $n == 1 and $k == 1,
        unquote('#{nth($siblings, $n)} + #{nth($items, $k)}'),
        append($out, unquote(', #{nth($siblings,$n)} + #{nth($items, $k)}'))
      );
    }
  }
  #{$out} { @content; }
}

@mixin adjacent-to($args...) {
  @if length($args) == 0 {
    & + & { @content; }
  } @else {
    @if type-of(nth($args, 1)) == list { $args: join((), $args...); }
    $arr: '';
    @for $n from 1 through length($args) {
      $arr: if($n == 1, unquote('#{nth($args, 1)} + &'), append($arr, unquote(', #{nth($args,$n)} + &')));
    }
    #{$arr} { @content; }
  }
}
