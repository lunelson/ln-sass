@function slice($list, $start: 1, $end: length($list), $sep: list-separator($list)) {
  $output: ();
  @if $start >= 1 and $end >= $start {
    @for $i from $start through $end {
      $output: append($output, nth($list, $i), $sep);
    }
  }
  @return $output;
}

@function last-sels() {
  $sel: &; $out: ();
  @each $list in $sel {
    $curr: nth($list, length($list));
    @if not index($out, $curr) {
      $out: append($out, $curr, 'comma');
    }
  }
  @return $out;
}

@function initial-sels() {
  $sel: &; $out: ();
  @each $list in $sel {
    $curr: slice($list, 1,  length($list) - 1);
    @if not index($out, $curr) {
      $out: append($out, $curr, 'comma');
    }
  }
  @return $out;
}

// a more fault-tolerant nth() function. libsass throws more errors for nth
@function _nth($list, $n) {
  @if length($list) == 0 or $n < 1 or $n > length($list) { @return null; }
  @return nth($list, $n);
}

@function sibling-to($siblings, $op: '~'){
  $initials: initial-sels();
  $lasts: last-sels();
  $out: '';
  @for $i from 1 through length($initials) {
    @for $s from 1 through length($siblings) {
      @for $l from 1 through length($lasts) {
        $out: if(
          ($i $s $l) == (1 1 1),
          '#{nth($initials, $i)} #{nth($siblings, $s)} #{$op} #{nth($lasts, $l)}',
          $out + ', #{nth($initials, $i)} #{nth($siblings, $s)} #{$op} #{nth($lasts, $l)}'
        );
      }
    }
  }
  @return $out;
}

@mixin sibling-to($args...) {
  @at-root #{unquote(sibling-to($args...))} {
    @content;
  }
}

.test .nest, .other .nest {
  p {

    // debug selectors
    initial-selectors: inspect(initial-sels());
    last-selectors: inspect(last-sels());

    // build sibling selector
    @include sibling-to(h1 h2, '+') {
      color: blue;
    }
  }
}