////////////////////////////
// MEDIA OBJECT functions //
////////////////////////////


// medium objects
@function medium($m: $curr-medium-key) { @return if($m, map-get($media, $m), $base); }
@function medium-orig($m: $curr-medium-key) { @return if($m, map-get($media-orig, $m), $base-orig); }

// medium values
@function medium-value($key, $m: $curr-medium-key) { @return if($m, map-get(medium($m), $key), map-get($base, $key)); }
@function mval($args...){ @return medium-value($args...); }
@function medium-orig-value($key, $m: $curr-medium-key) { @return if($m, map-get(medium-orig($m), $key), map-get($base-orig, $key)); }
@function mval-orig($args...){ @return medium-orig-value($args...); }

////////////////////////////
// normalize medium units //
////////////////////////////

@function normalize-medium($medium) {

  // correct for font-size and line-height units/non-units
  $font-size: map-get($medium, 'font-size');
  $line-height: map-get($medium, 'line-height');
  $base-size: if($medium == $base, 16px, map-get($base, 'font-size'));
  @if unit($font-size) != 'px' { $font-size: unit-strip($font-size) * $base-size; }
  @if unit($line-height) == 'px' { $line-height: $line-height / $font-size; }

  // put these in a new map
  $normal: (
    'font-size': $font-size,
    'line-height': $line-height,
    'html-scale': unit-strip($font-size / 16px)
  );

  // merge additional corrections if necessary
  @each $key, $value in map-remove($medium, 'font-size', 'line-height', 'breakpoint', 'sizes', 'lines', 'mults-x', 'mults-y') {
    @if unit($value) == 'px' { $normal: map-merge($normal, ($key: $value / $font-size * 1rem)); }
  }
  // return merged corrections
  @return map-merge($medium, $normal);
}

// media query string
@function width-query($min: null, $max: null) {
  $min: if(map-has-key($media, $min), get($media, $min, 'breakpoint'), $min);
  $max: if(map-has-key($media, $max), get($media, $max, 'breakpoint'), $max);
  @return 'screen'
    + if($min, ' and (min-width: #{$min})', '')
    + if($max, ' and (max-width: #{$max - 0.001})', '');
}

//////////////////////////////////
// MEDIA FUNCTIONS AND MIXINS I //
//////////////////////////////////

// single query
@mixin media-single($min, $max: null) {
  $prev-medium-key: $curr-medium-key;
  $curr-medium-key: $min !global;
  @media #{width-query($min, $max)} { @content }
  $curr-medium-key: $prev-medium-key !global;
}

// multiple queries
@mixin media-multi($from: null, $to: null, $for: null, $at: null) {
  // normalize inputs
  // $from: $from or nth(map-keys($media), 1);
  // $to: $to or null;
  // @if $for {
  //   @if contains($for, typo) { $for: join($for, margin-y line-height font-size-mod); }
  //   @if contains($for, margin-y) { $for: join($for, margin-y-mod); }
  //   @if contains($for, font-size) { $for: join($for, font-size-mod); }
  //   @if contains($for, margin-x) { $for: join($for, margin-x-mod); }
  // }

  @if $at {
    @each $medium in $at {
      $orig-keys: map-keys(medium-orig($medium));
      // if there's no "for" condition, do the medium
      @if not $for { @include media-single($medium) { @content; } }
      // if there is a "for" condition, do medium only if the "for" key exists for medium
      @else if contains-any($orig-keys, $for) { @include media-single($medium) { @content; } }
    }
  } @else {
    // output the @content for $base medium if $from is null
    @if $from == null { @content; }

    // determine other referenced media
    $media-keys: map-keys($media);
    $from-index: if($from, index($media-keys, $from), 1);
    $to-index: if($to, index($media-keys, $to) - 1, length($media-keys));
    $sliced-keys: join(slice($media-keys, $from-index, $to-index), $to);
    $sliced-length: length($sliced-keys);

    // conditional per-medium actions
    @for $n from 1 to $sliced-length {
      $curr: nth($sliced-keys, $n);
      // $next: nth($sliced-keys, $n + 1);
      $orig-keys: map-keys(medium-orig($curr));
      // if there's no "for" condition, do the medium
      @if not $for { @include media-single($curr, $to) { @content; } }
      // if there is a "for" condition, do medium only if the "for" key exists for medium
      @else if contains-any($orig-keys, $for) { @include media-single($curr, $to) { @content; } }
    }
  }
}

// unified media query mixin -- calls mixins above
@mixin media($args...) {
  $arg1: nth($args, 1);
  @if index('map' 'list', type-of($arg1)) { @include media-multi($arg1...) { @content; } }
  @else { @include media-single($args...) { @content; } }
}


// hidpi / retina query; should combine with media() via nesting
@mixin hidpi($ratio: $media-hd-ratio) {
  $n: nth($ratio, 1); $d: nth($ratio, 2);
  $ratio: ($n / $d);
  @media screen and
  (-webkit-min-device-pixel-ratio: $ratio),
  (min--moz-device-pixel-ratio: $ratio),
  (-o-min-device-pixel-ratio: #{$n}/#{$d}),
  (min-device-pixel-ratio: $ratio),
  (min-resolution: $ratio * 96dpi),
  (min-resolution: $ratio * 1dppx) {
    @content;
  }
}
// alias
@mixin hd($args...) { @include hidpi($args...) { @content; } }

/////////////////////
// MEDIA MIXINS II //
/////////////////////

@function media-for($props){
  $keys: ();
  $groups: (
    font-size sizes size-mod,
    line-height lines,
    margin-y mults-y mult-y-mod,
    margin-x mults-x mult-x-mod,
  );
  @each $prop in $props {
    @each $group in $groups {
      @if index($group, $prop) {
        $props: join($props, $group);
      }
    }
  }
  @each $m, $medium in $media-orig {
    @if contains-any(map-keys($medium), $props) {
      $keys: append($keys, $m);
    }
  }
  @return $keys;
}

@mixin media-each($keys: map-keys($media)) {
  @each $min-max in pair-set($keys) {
    @include media($min-max...) {
      @content;
    }
  }
}

@mixin media-for($props) { @include media-each(media-for($props)) { @content; } }
